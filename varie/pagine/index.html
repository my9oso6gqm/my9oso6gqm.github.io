<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Passphrase"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"1a97dfc422e9136583f428b543e63d0b42c21b2734c98a5c112e3756da0acd1619df8168ccd4a4fb40010d04d9cc00354fb7e386ec7dbbf22607757eb8697cb98746b087f1e411fcaa765bf7580d73c03b852781394a859571fff9fbc1f19d0aa876324a133b18fc5fbcf769c7f98d094519414890e6262a73fd07dd8f0653be23c0a65b6a518dce584895e060a5b7e2a5ce2f7c7a294a0b82b8b5bd1cad0586e1706c3de12980b9c85e8da053a855e3d9036a282427366fba648bffd80ee530e5ff512e321f8cca1122151d6484fb6df76c2655fe81bccf89b4b4163ee2f470e3dfd8c4f17cd9e5963f547a2bf23ecd524cd773bbb5d4853f82f282d314b584e9664a2f79c1764d889dee329953f839a314236ee12b95cef2b61edf62e77f0901ed5678268baa452c162d2d4b3a1c34ae3f372496b9839cc7d2647c56ba46d483c0131f5dfecd7c285459a66cc9f4b2b8e5557c9698cc831594096dce516d24f79f8a1a9b77487f5de07276dfc67762c0a0b1e70f34c5c1b3dcb697203657719a189bc862a6f06850da59a2e274d38d46649807cb355a3f2200643e12b09ce920f7580c02665032850c2e9e3c441a4952c24260715e3aa24747168644e9ac9aeb4b45612e9e24a89bfb92421e56d8de7c40efbbda6ef2b5b6f8da7e0e5b68d280f817614b6044100008680ce8dc0764b2a56ecb14d200a6f31976a6d95820a5aece99ab99803fecf37f8bbf5f7fc9ab0d68b48a1f415bda010a7192b8c838047bc1332673c5ac331d7d7db63da1f65ab961e5da771a9f734d7b81a0d724075ec2991179e4a7da9a29a6ce488d4a395035e151069061a847d86c3713563506acb76c0b9bf7f4221f190a3a8c272b7d8a587a01304cd245c9c05453569784108d0c4ccb6fcfba0054072d5de32281ace648a34ea4e8c5a80977a610aa0f0f1d103392b9e03dd2f5e2a455eabae3943e5982c67c5eda2ba5911001d083a729a9809c4630a125b362e491f98ed39b035d90fc0b44ef58d7a3cdfa2b03bcdd4c66866f4c2824964be205e3f495027bfa6c211aadf1d071d36ec9db74aa91603c62d80a7045d04d7e88d5650c27f1a6adb2cf980ffed2e7b69c5ecbc87963b821c7cd05f396480d3f9f1ff79319735b3d497f3513a71818ce4ebb2c0036512ed8722288e50c7b12c1fd73847635b627181f53601f6bb8ffdd11b7f281268ca3bf0b8f065297aec250ae4523201d8c1128fa5fc68b6b6a99c1bd2ffa644f49c39d1ea60931a2daa8dafe9bc376cdb4aca528e767acc070223f04f52216c0d65bd8d0ceaeddcac3ad1253d196a2d728125b670fdfab323461185d42fbf96a6ab33ef3381da623fb45fd9262340cff3d8dff00337d813de9a4d3c84dac253d2c4cb18c065494d837bf204b610b5a4d386c1d90f4591bcce30c4a77eea98ff6dd9c5c82399b4dc9572285b774f2fe655b4d18090c4c335e1c83c4fdd64d4749477392acfc41ef8e19c2b138f24eeecbff931136017e6f28aafc799d21d3f168bff87bb8d4af6dd143709302e3bbc1c546c44ed98b9ec19633003dca66a39b4793dd105f17e2355d13a00eb6fed018b6bf3e98d667c725d53a83e586ab774adbb77063f654dc056b13aafb810c057883280777a9c07317088dec27bc365b7d4bd6ca804942485f5162c4605340c27a470bc85eb417e150e442dac9e695faef66a5601a0aca7c71a78291c9d9c8b3c82085c05aa95559e384bd314ffbed2b01057ae3097efade5026c8a2a08d1c8d03290eab2e63bb620797d2307ea74f8b80666c6e7e6aaa0aaa9d4963f939055a47ff1a0cf03e4db15e85300f4b671ab35031fdc6a9a49a0a721e74fc759d67ce2e86a706c7cfe63963394e14c5cb3ad1fa4ed78588ae019e93349d71f062d9ae92d94b4e8fc6810fa8044fcc036e8c95627d5c1d3cfe5fc9180143693f26e9c280b6a8e22b8c4c214e2dcfea83acae9104b0d783f45dfa93133bcebe7a1ed410659588fdf0707390f5547494742c16c21739f47c9b7f5b2629e246517e6889e873f86da008b311e92b9a86270ad431c2f9bcb395302f862bae84e912d2625bb05c2a86ac6ac81933777d2a1fb7d3a82700590ea88d276c1acef209d5566a34bc62b8a2cab3613242a1a6b06fab3bbdf8d690a628eaafaf81a1226d2f4a2888cdbba24fa611f27dab609a7979aa5da6e66876ce032e7a9924bc08f069db36e1a030ebf5677ce777af0bc8ceb19cf6b68418fa22413ddddfcbef6bc2237555c5e41b137079f80f9e00e6197d12ea0bd0276d807f4223f896fa9a0349436fe36845a878b2d0b19c48159d1036cd80dae8b00bc91baff32f3f38f6e474a990e00436a25f55ad881ca211700236a8300c070f07b05328616e96a4719845ed2e5db3fa099f9d5686bf381462c71b1082a668d02a1e00dd9f51623c6573f04875a44af69f23300cb01885f95fc5e31d6f378769c7157954a5382e45cd34c75865cc153a8be9b6fb0bfd3f32ec3e907510e43e805dadf93f2ab44e66e7ccc46467b011fe4459cb432916a170085a4692e27ac21be15748e2d4384bb3edb54400c4fa0405b10add6f1bd985205e48fd50c6e2b275bfa3833e60d7405cf3fbf70b715285978ff2a4b967b27b5e0238a310c94f5b58d784e40ffca83e346e3563aacbe55b8c5c12599bf12cdd1cd58674ea123e6cf0f01fc4f92f657a43e4092a66f98f0098cc5800afc9c6010d89dae55039abf4606cd90634fe21295c60e46220283b375889d5e632917dd232b29c61275f25e9e2a5063484f3ca8506bc0056c401aafa40905da5dca7e9093dc70c07b52720433d83eddd83799cfdcac772bba8f17fe1c9f433f9cc4dcf3a2b8184ed5d994ca89bef44afb1db61e6d053f2744754522371e025b31fd8dead1cc7d1031abf21de16fde0f6f2a0a5910f2bbeec3486cc74b9f4d292633413361cece7a80bf1d660296fdb9e63f541dcba3ebc27f3b9d4ede23c3f06931d909c5ff6b67da46b9b53c4631fbe7844a2eb62b8a4b8bb9b9b3a3e479d47265c9153096793912aeda91df0e55fbd7985eb657b2745f143ec64895e73266961139569882df5ad107a3c9c9c4b630c319683069eac340b11dfbc0b69bbabef12cea5aaf87c26879cd13678e6e6e2ad1782b64e7447a67570eaae697da09f5779dfea1d1da058ac2d56571e7a6de42e32646d16fa3793f7951971b8bdf8ba228033b28de54089a7037fbfb6513d26242dae432ad1021f312820a41be7e164a3e9acb1c41f7f5ca62ce13d5f6c0ecc1cc3f10243a059c2843975026a810279d4dbcb1e34c4e8918679a2dd8e83e260f2931695b0683fdbe41bd9d1978284af12979a2cbc64ade6d0cbec115990b2fdda814b13eb18af734ea64f5ede59b31b3116569e77d99887cca02f8823df62dd1ce6dbfc94c66350e0605cf15125d94a73fc3693b7ad4c8966a9e3990941df6e0da170cb47282a2cbcb5d83d0fec5fa36188476cd063d34a871d1edee2c53ef33f543e6aba340498342596f0cf1aedcb6de81e592f67bac21efca18a7b0fc7db1e5b5cd8f45f40d7ec70dc176dfb8010cf291fd4a7152d2ba1e32869e8fe45b66c21de29e9deb58371f5521e39d36c08b2fae1af1f8742a7aa488968db75e60826875592da0f0ec2ec4aaae02b8226bd5783f379498434ee04dc28f7799aabda39af1e772ed79ae3ee414cb932c5e0df4bd1251a71cb6726080d34216d3ff2b56942179c6e3d8f51436e0cf2b9fbfec1e2365a84e4806d31e16a54398bd472253f9bd8432f2bff0417ab4120c938c08d68b83e0c8ddf1ead5ca5ceaad0280bc46722415ef93f8070716734223b506c5faa50516913d4d25de0ecff8154793bc7c5f433f4dd4673a168c60f4545e52b4645c5a79a0460ea3cb426190a49ef7ab4387319ac51071a1e439efbb53def4fc89a3a41b2f623b5dc2a17f7d0f514d7e021e6ecdbb96f60b7836fac06f7c129c76e0697b6de0cf6815be1d7a71806e7be0a4cabf104cb7e0b7b2283095c0864284b66e3f100719c722eb0fa523f807a070c1b599de016fb3b27e2efc31a6b8d851c033976a4cac292b7647013ae1cb9f34dd89de1b5beeba4d3137fd499155c8716d60f81f23574dea3ed5ebb3e2016feb67528133391eb28b1f964a1f9c02f271781f1aded6d18fb47d10ad082ec604b5ba76cd6ba2ffdec3cd69dbb7e8590a472d6608b753371c510d25ad15f0a6285f12296f8038b4b155e23f43651c44820ca10e33d67149979ee42f89d55fb7c78d9c3fbee08020edf138c008534529f260ce49de2e8051fd38bc2cd6bb0dccff3c4b5852ddd96f8cc4a51554e00bba9d6836d6c615892afb265c7969ad52cdd7db47a9d8104c6f512605281b3940541b4082f57c006198e6fe2ddcb9bb6177cc6b87d33d149a8916c32fce441fcdd9f84148f93dbd63ec2a180b51249554c74ecc26b45d74b04f7bb9c43dc905c122edb1cf560e18137dbe6546ac8fc725a26e232a9ab01f6","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"cdf308ff8d7f48c6620c500c93de5705"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
